generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum HeatSignupStatus {
  UNBEATEN
  BEATEN
  GIVEN_UP
}

model User {
  id           String   @id @default(cuid())
  username     String   @unique
  passwordHash String
  isAdmin      Boolean  @default(false)
  createdAt    DateTime @default(now())

  // Implicit M:N relation: user signups to gauntlets
  gauntlets   Gauntlet[]
  // Per-heat participation
  heatSignups HeatSignup[]
}

model Platform {
  id           String  @id @default(cuid())
  igdbId       Int     @unique
  name         String
  abbreviation String?
  generation   Int?

  games Game[]
  heats Heat[]
  // Rolled games in signups optionally reference a platform
  rolls HeatRoll[] @relation("HeatRollPlatform")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

model Game {
  id       String  @id @default(cuid())
  igdbId   Int     @unique
  name     String
  slug     String? @unique
  coverUrl String?

  // IGDB first_release_date stored twice as requested
  releaseDateUnix  Int? // seconds since epoch
  releaseDateHuman String?

  // Whether this game had a Western-region release (NA/EU/AU/Worldwide) according to IGDB
  hasWesternRelease Boolean @default(false)

  platforms         Platform[]
  // Per-user selected game for a heat
  selectedInSignups HeatSignup[] @relation("HeatSignupSelectedGame")
  // Rolled appearances across signups
  rolls             HeatRoll[]   @relation("HeatRollGame")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

model Gauntlet {
  id   String @id @default(cuid())
  name String

  heats Heat[]
  // Implicit M:N relation: gauntlet signups
  users User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

model Heat {
  id                 String     @id @default(cuid())
  gauntletId         String
  gauntlet           Gauntlet   @relation(fields: [gauntletId], references: [id])
  name               String?
  order              Int
  startsAt           DateTime   @db.Date
  endsAt             DateTime   @db.Date
  platforms          Platform[]
  defaultGameCounter Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Users participating in this heat
  signups HeatSignup[]

  @@index([gauntletId, order])
}

model HeatSignup {
  id             String  @id @default(cuid())
  heatId         String
  heat           Heat    @relation(fields: [heatId], references: [id])
  userId         String
  user           User    @relation(fields: [userId], references: [id])
  selectedGameId String?
  selectedGame   Game?   @relation("HeatSignupSelectedGame", fields: [selectedGameId], references: [id])

  status HeatSignupStatus @default(UNBEATEN)

  // Locked per-platform roll targets for this signup (platformId -> count)
  platformTargets Json?

  // Minimum number of rolled games that must have a Western-region release
  westernRequired Int @default(0)

  rolls HeatRoll[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([heatId, userId])
}

model HeatRoll {
  id           String     @id @default(cuid())
  heatSignupId String
  heatSignup   HeatSignup @relation(fields: [heatSignupId], references: [id])
  gameId       String
  game         Game       @relation("HeatRollGame", fields: [gameId], references: [id])
  platformId   String?
  platform     Platform?  @relation("HeatRollPlatform", fields: [platformId], references: [id])
  order        Int
  createdAt    DateTime   @default(now())

  @@unique([heatSignupId, order])
  @@index([heatSignupId])
}
